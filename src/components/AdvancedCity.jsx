import { useRef, useMemo } from 'react'\nimport { useFrame } from '@react-three/fiber'\nimport { Float, Text } from '@react-three/drei'\nimport HologramMesh from './HologramMaterial'\nimport * as THREE from 'three'\n\nconst Building = ({ position, height, color, animated = false }) => {\n  const meshRef = useRef()\n  \n  useFrame((state) => {\n    if (animated && meshRef.current) {\n      meshRef.current.position.y = height/2 + Math.sin(state.clock.elapsedTime + position[0]) * 0.5\n    }\n  })\n  \n  return (\n    <group position={position}>\n      <mesh ref={meshRef} castShadow receiveShadow>\n        <boxGeometry args={[1, height, 1]} />\n        <meshPhysicalMaterial \n          color={color}\n          metalness={0.8}\n          roughness={0.2}\n          emissive={color}\n          emissiveIntensity={0.1}\n        />\n      </mesh>\n      \n      {/* Building lights */}\n      {[...Array(Math.floor(height/2))].map((_, i) => (\n        <pointLight\n          key={i}\n          position={[0, i * 2 - height/2, 0.6]}\n          intensity={0.5}\n          distance={3}\n          color={color}\n        />\n      ))}\n    </group>\n  )\n}\n\nconst FlyingVehicle = ({ path, speed = 1 }) => {\n  const vehicleRef = useRef()\n  \n  useFrame((state) => {\n    if (vehicleRef.current) {\n      const t = (state.clock.elapsedTime * speed) % 1\n      const curve = new THREE.CatmullRomCurve3(path)\n      const position = curve.getPoint(t)\n      const tangent = curve.getTangent(t)\n      \n      vehicleRef.current.position.copy(position)\n      vehicleRef.current.lookAt(position.clone().add(tangent))\n    }\n  })\n  \n  return (\n    <HologramMesh ref={vehicleRef}>\n      <coneGeometry args={[0.2, 1, 8]} />\n    </HologramMesh>\n  )\n}\n\nconst DataStream = ({ start, end, color = '#00f5ff' }) => {\n  const streamRef = useRef()\n  const points = useMemo(() => {\n    const curve = new THREE.QuadraticBezierCurve3(\n      new THREE.Vector3(...start),\n      new THREE.Vector3(\n        (start[0] + end[0]) / 2,\n        Math.max(start[1], end[1]) + 5,\n        (start[2] + end[2]) / 2\n      ),\n      new THREE.Vector3(...end)\n    )\n    return curve.getPoints(50)\n  }, [start, end])\n  \n  useFrame((state) => {\n    if (streamRef.current) {\n      streamRef.current.material.opacity = 0.5 + Math.sin(state.clock.elapsedTime * 3) * 0.3\n    }\n  })\n  \n  return (\n    <line ref={streamRef}>\n      <bufferGeometry>\n        <bufferAttribute\n          attach=\"attributes-position\"\n          count={points.length}\n          array={new Float32Array(points.flatMap(p => [p.x, p.y, p.z]))}\n          itemSize={3}\n        />\n      </bufferGeometry>\n      <lineBasicMaterial color={color} transparent />\n    </line>\n  )\n}\n\nexport default function AdvancedCity() {\n  const cityData = useMemo(() => {\n    const buildings = []\n    const vehicles = []\n    const streams = []\n    \n    // Generate complex city layout\n    for (let x = -20; x <= 20; x += 3) {\n      for (let z = -20; z <= 20; z += 3) {\n        if (Math.random() > 0.3) {\n          const height = 2 + Math.random() * 8\n          const color = ['#1a1a2e', '#16213e', '#0f3460', '#533483'][Math.floor(Math.random() * 4)]\n          buildings.push({\n            position: [x + (Math.random() - 0.5), height/2, z + (Math.random() - 0.5)],\n            height,\n            color,\n            animated: Math.random() > 0.8\n          })\n        }\n      }\n    }\n    \n    // Generate flying vehicles\n    for (let i = 0; i < 10; i++) {\n      const path = [\n        new THREE.Vector3(-25, 8 + Math.random() * 5, -25),\n        new THREE.Vector3(0, 12 + Math.random() * 8, 0),\n        new THREE.Vector3(25, 8 + Math.random() * 5, 25),\n        new THREE.Vector3(0, 15 + Math.random() * 5, -25)\n      ]\n      vehicles.push({ path, speed: 0.1 + Math.random() * 0.2 })\n    }\n    \n    // Generate data streams\n    for (let i = 0; i < 20; i++) {\n      streams.push({\n        start: [Math.random() * 40 - 20, Math.random() * 10, Math.random() * 40 - 20],\n        end: [Math.random() * 40 - 20, Math.random() * 10, Math.random() * 40 - 20],\n        color: ['#00f5ff', '#8b5cf6', '#ffd700'][Math.floor(Math.random() * 3)]\n      })\n    }\n    \n    return { buildings, vehicles, streams }\n  }, [])\n  \n  return (\n    <group>\n      {/* Buildings */}\n      {cityData.buildings.map((building, i) => (\n        <Building key={i} {...building} />\n      ))}\n      \n      {/* Flying vehicles */}\n      {cityData.vehicles.map((vehicle, i) => (\n        <FlyingVehicle key={i} {...vehicle} />\n      ))}\n      \n      {/* Data streams */}\n      {cityData.streams.map((stream, i) => (\n        <DataStream key={i} {...stream} />\n      ))}\n      \n      {/* Ground */}\n      <mesh position={[0, -1, 0]} receiveShadow>\n        <planeGeometry args={[100, 100]} />\n        <meshPhysicalMaterial \n          color=\"#0a0a0a\"\n          metalness={0.9}\n          roughness={0.1}\n          reflectivity={0.8}\n        />\n      </mesh>\n    </group>\n  )\n}