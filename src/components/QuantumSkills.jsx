import { useRef, useState, useMemo } from 'react'\nimport { useFrame } from '@react-three/fiber'\nimport { Float, Text, Trail } from '@react-three/drei'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport HologramMesh from './HologramMaterial'\nimport ParticleSystem from './ParticleSystem'\nimport * as THREE from 'three'\n\nconst QuantumOrb = ({ position, skill, onClick, isActive }) => {\n  const orbRef = useRef()\n  const [hovered, setHovered] = useState(false)\n  const [energy, setEnergy] = useState(0)\n  \n  const orbGeometry = useMemo(() => {\n    const geometry = new THREE.IcosahedronGeometry(1, 2)\n    const positions = geometry.attributes.position.array\n    \n    // Add quantum fluctuations to vertices\n    for (let i = 0; i < positions.length; i += 3) {\n      const vertex = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2])\n      const noise = Math.random() * 0.1\n      vertex.multiplyScalar(1 + noise)\n      positions[i] = vertex.x\n      positions[i + 1] = vertex.y\n      positions[i + 2] = vertex.z\n    }\n    \n    return geometry\n  }, [])\n  \n  useFrame((state) => {\n    if (orbRef.current) {\n      orbRef.current.rotation.x = state.clock.elapsedTime * 0.5\n      orbRef.current.rotation.y = state.clock.elapsedTime * 0.3\n      orbRef.current.rotation.z = state.clock.elapsedTime * 0.2\n      \n      const scale = 1 + Math.sin(state.clock.elapsedTime * 2) * 0.1\n      orbRef.current.scale.setScalar(hovered ? scale * 1.3 : scale)\n      \n      if (isActive) {\n        setEnergy(prev => Math.min(prev + 0.02, 1))\n      }\n    }\n  })\n  \n  return (\n    <Float speed={2} rotationIntensity={1} floatIntensity={0.5}>\n      <group position={position}>\n        {/* Quantum pedestal */}\n        <HologramMesh position={[0, -2, 0]}>\n          <cylinderGeometry args={[0.8, 1.2, 0.5, 12]} />\n        </HologramMesh>\n        \n        {/* Energy rings */}\n        {[...Array(3)].map((_, i) => (\n          <HologramMesh \n            key={i} \n            position={[0, -1 + i * 0.3, 0]}\n            rotation={[0, state.clock?.elapsedTime * (i + 1) * 0.5 || 0, 0]}\n          >\n            <torusGeometry args={[1.5 + i * 0.2, 0.05, 8, 32]} />\n          </HologramMesh>\n        ))}\n        \n        {/* Main quantum orb */}\n        <Trail\n          width={2}\n          length={6}\n          color={skill.color}\n          attenuation={(t) => t * t}\n        >\n          <mesh\n            ref={orbRef}\n            geometry={orbGeometry}\n            onPointerEnter={() => setHovered(true)}\n            onPointerLeave={() => setHovered(false)}\n            onClick={onClick}\n          >\n            <meshPhysicalMaterial\n              color={skill.color}\n              transparent\n              opacity={0.8}\n              roughness={0}\n              metalness={0.5}\n              clearcoat={1}\n              clearcoatRoughness={0}\n              transmission={0.3}\n              ior={1.5}\n              emissive={skill.color}\n              emissiveIntensity={energy * 0.5}\n            />\n          </mesh>\n        </Trail>\n        \n        {/* Skill particles */}\n        <ParticleSystem count={200} color={skill.color} />\n        \n        {/* Skill label */}\n        <Text\n          position={[0, -3, 0]}\n          fontSize={0.3}\n          color=\"#ffffff\"\n          anchorX=\"center\"\n          anchorY=\"middle\"\n          font=\"/fonts/orbitron.woff\"\n        >\n          {skill.name}\n        </Text>\n        \n        {/* Proficiency level */}\n        <Text\n          position={[0, -3.5, 0]}\n          fontSize={0.2}\n          color={skill.color}\n          anchorX=\"center\"\n          anchorY=\"middle\"\n        >\n          {skill.level}% MASTERY\n        </Text>\n        \n        {/* Quantum field distortion */}\n        {hovered && (\n          <mesh>\n            <sphereGeometry args={[3, 32, 32]} />\n            <meshBasicMaterial\n              color={skill.color}\n              transparent\n              opacity={0.1}\n              side={THREE.BackSide}\n            />\n          </mesh>\n        )}\n      </group>\n    </Float>\n  )\n}\n\nconst SkillNetwork = ({ skills, activeSkills }) => {\n  const networkRef = useRef()\n  \n  useFrame((state) => {\n    if (networkRef.current) {\n      networkRef.current.rotation.y = state.clock.elapsedTime * 0.05\n    }\n  })\n  \n  return (\n    <group ref={networkRef}>\n      {skills.map((skill, i) => {\n        const nextSkill = skills[(i + 1) % skills.length]\n        const isConnected = activeSkills.includes(skill.name) && activeSkills.includes(nextSkill.name)\n        \n        return (\n          <line key={`connection-${i}`}>\n            <bufferGeometry>\n              <bufferAttribute\n                attach=\"attributes-position\"\n                count={2}\n                array={new Float32Array([\n                  ...skill.position,\n                  ...nextSkill.position\n                ])}\n                itemSize={3}\n              />\n            </bufferGeometry>\n            <lineBasicMaterial \n              color={isConnected ? \"#ffd700\" : \"#333\"}\n              transparent \n              opacity={isConnected ? 0.8 : 0.2}\n            />\n          </line>\n        )\n      })}\n    </group>\n  )\n}\n\nexport default function QuantumSkills({ onSkillClick, activeSkills = [] }) {\n  const skills = useMemo(() => [\n    { \n      name: 'QUANTUM REACT', \n      color: '#61dafb', \n      level: 95,\n      position: [0, 0, 4]\n    },\n    { \n      name: 'NEURAL NODE.JS', \n      color: '#68a063', \n      level: 90,\n      position: [3.5, 0, 2]\n    },\n    { \n      name: 'DIMENSIONAL THREE.JS', \n      color: '#000000', \n      level: 88,\n      position: [3.5, 0, -2]\n    },\n    { \n      name: 'QUANTUM PYTHON', \n      color: '#3776ab', \n      level: 85,\n      position: [0, 0, -4]\n    },\n    { \n      name: 'COSMIC MONGODB', \n      color: '#47a248', \n      level: 82,\n      position: [-3.5, 0, -2]\n    },\n    { \n      name: 'HYPERSPACE AWS', \n      color: '#ff9900', \n      level: 87,\n      position: [-3.5, 0, 2]\n    },\n    { \n      name: 'BLOCKCHAIN NEXUS', \n      color: '#f7931a', \n      level: 78,\n      position: [0, 3, 0]\n    },\n    { \n      name: 'AI MATRIX', \n      color: '#8b5cf6', \n      level: 80,\n      position: [0, -3, 0]\n    }\n  ], [])\n  \n  return (\n    <group>\n      <SkillNetwork skills={skills} activeSkills={activeSkills} />\n      \n      {skills.map((skill, index) => (\n        <QuantumOrb\n          key={skill.name}\n          position={skill.position}\n          skill={skill}\n          onClick={() => onSkillClick(skill)}\n          isActive={activeSkills.includes(skill.name)}\n        />\n      ))}\n      \n      {/* Central quantum core */}\n      <HologramMesh>\n        <octahedronGeometry args={[0.5]} />\n      </HologramMesh>\n      \n      {/* Ambient quantum particles */}\n      <ParticleSystem count={1000} color=\"#8b5cf6\" />\n    </group>\n  )\n}